//go:build ignore

package main

import (
        "crypto/rand"
        "encoding/hex"
        "flag" // Import the flag package
        "fmt"
        "io/ioutil"
        "log"
        "strings"
)

var (
        // The -gatewaykey flag is still useful for explicit usage,
        // but we'll also check positional arguments.
        gatewayKeyFileFlag string
)

func init() {
        // Define the command-line flag for explicit use
        flag.StringVar(&gatewayKeyFileFlag, "gatewaykey", "", "Path to the gateway key file to embed in the relay. If not provided, the first positional argument will be used.")
}

func main() {
        flag.Parse() // Parse the command-line arguments

        // Determine the actual key file path
        var keyFilePath string
        if gatewayKeyFileFlag != "" {
                // If -gatewaykey flag was explicitly used
                keyFilePath = gatewayKeyFileFlag
        } else if len(flag.Args()) > 0 {
                // If no -gatewaykey flag, check for a positional argument
                keyFilePath = flag.Args()[0]
        } else {
                // If neither flag nor positional argument, default to "relay.key"
                keyFilePath = "relay.key"
        }

        keyHex, err := ioutil.ReadFile(keyFilePath) // Use the determined key file path
        if err != nil {
                log.Fatalf("Failed to read key file %s: %v", keyFilePath, err)
        }
        key, err := hex.DecodeString(strings.TrimSpace(string(keyHex)))
        if err != nil {
                log.Fatalf("Failed to decode key hex from %s: %v", keyFilePath, err)
        }
        if len(key) != 32 {
                log.Fatalf("Invalid key length in %s: expected 32 bytes, got %d", keyFilePath, len(key))
        }

        obfuscatedKey := make([]byte, len(key))
        xorKey := make([]byte, len(key))
        if _, err := rand.Read(xorKey); err != nil {
                log.Fatalf("Failed to generate XOR key: %v", err)
        }

        for i := 0; i < len(key); i++ {
                obfuscatedKey[i] = key[i] ^ xorKey[i]
        }

        output := fmt.Sprintf(`// Code generated by preparekey.go. DO NOT EDIT.
package main

var (
        obfuscatedRelayKey = []byte{ %s }
        xorRelayKey        = []byte{ %s }
)

func getRelayKey() []byte {
        key := make([]byte, len(obfuscatedRelayKey))
        for i := 0; i < len(obfuscatedRelayKey); i++ {
                key[i] = obfuscatedRelayKey[i] ^ xorRelayKey[i]
        }
        return key
}
`, byteSliceToHexString(obfuscatedKey), byteSliceToHexString(xorKey))

        if err := ioutil.WriteFile("relay_key.go", []byte(output), 0644); err != nil {
                log.Fatalf("Failed to write relay_key.go: %v", err)
        }
        log.Println("Successfully generated relay_key.go")
}

func byteSliceToHexString(data []byte) string {
        parts := make([]string, len(data))
        for i, b := range data {
                parts[i] = fmt.Sprintf("0x%02x", b)
        }
        return strings.Join(parts, ", ")
}
